\paragraph{Generating more complex sequences}

This sequence is not easily translated into a combination of the sequences in the previous paragraph:

\texttt{1 2 4 8 16 32 ...}

However, the rhythm is not too complicated: each number in the sequence is the previous number, times 2. To generate the sequence, we need more than just a formula: we need to add a variable that \emph{tracks} the state of the sequence while generating it.

\begin{nnflisting}
number = 1
for(i = 0; i < 10; i++)
    print(number)
    number = number * 2
\end{nnflisting}

The loop now has a few more components. On line 1, the \emph{initial} number is set to 1, the first number of our sequence. Like before, line 2 controls the amount of numbers that are generated by the loop. Line 3 only prints the \emph{current} number, without doing any calculations. Line 4 \emph{updates} the number, calculating the next number from the current one.

Do not forget to trace the algorithms that you write, to ensure that they work well!

% We kunnen weer hetzelfde framework gebruiken voor deze reeks:

% \begin{verbatim}
% 1 for(i = 0; i < 10; i++)
% 2     getal = ???
% 3     print(getal)
% \end{verbatim}
%
%
% Om te weten wat \texttt{getal} zou moeten zijn kunnen we weer naar de trace voor dit algoritme kijken:
%
% \setlength{\tabcolsep}{2.5pt}
% \begin{tracelist-left}[l|cccccccccccccccccclc]
% regel & \texttt{1i} & \texttt{1c} & \texttt{2} & \texttt{3} & \texttt{1u} & \texttt{1c}
%                                   & \texttt{2} & \texttt{3} & \texttt{1u} & \texttt{1c}
%                                   & \texttt{2} & \texttt{3} & \texttt{1u} & \texttt{1c}
%                                   & \texttt{2} & \texttt{3} & \texttt{1u} & \texttt{1c} & ... \\ \hline
% var i & \fbox{\texttt{0}} & \texttt{0} & \texttt{0} & \texttt{0} &  \fbox{\texttt{1}} & \texttt{1}
%                                   & \texttt{1} & \texttt{1} & \fbox{\texttt{2}} & \texttt{2}
%                                   & \texttt{2} & \texttt{2} & \fbox{\texttt{3}} & \texttt{3}
%                                   & \texttt{3} & \texttt{3} & \fbox{\texttt{4}} & \texttt{4} & ...\\
% var getal &  &  & \fbox{\texttt{1}} & \texttt{1} & \texttt{1} & \texttt{1}
%                 & \fbox{\texttt{2}} & \texttt{2} & \texttt{2} & \texttt{2}
%                 & \fbox{\texttt{4}} & \texttt{4} & \texttt{4} & \texttt{4}
%                 & \fbox{\texttt{8}} & \texttt{8} & \texttt{8} & \texttt{8} & ... \\
% print &  &  &  & \texttt{1} & &
%             & & \texttt{2} & &
%             & & \texttt{4} & &
%             & & \texttt{8} & & & ...
% \end{tracelist-left}
% \setlength{\tabcolsep}{6pt}
%
% Het probleem is hier dat het verband tussen \texttt{getal} en \texttt{i} niet zo eenvoudig is als we bij eerdere reeksen hebben gezien: \texttt{getal = (i + 1)}$^2$. Hiervoor is dus machtsverheffing nodig. Op zich geen probleem, we zouden het algoritme met machtsverheffing correct kunnen uitwerken. Maar, het is een operatie die niet standaard aanwezig is in alle programmeertalen, en nodeloos complex in dit geval.
%
% Er is een makkelijkere manier om deze reeks te genereren. Als je nog eens kijkt naar de reeks, zie je dat \texttt{getal} begint op \texttt{1} en vervolgens elke stap verdubbelt. In plaats van \texttt{getal} afhankelijk te maken van \texttt{i} kunnen we dit patroon makkelijker repliceren door \texttt{getal} afhankelijk te maken van zichzelf:

% \begin{verbatim}
% 1  getal = 1
% 2 for(i = 0; i < 10; i++)
% 3     getal = getal * 2
% 4     print(getal)
% \end{verbatim}
%
% Zoals altijd met programmeren zijn er altijd vele oplossingen voor het zelfde probleem. Het is dan ook niet zo dat het bovenstaande algoritme de enige oplossing is voor de gegeven reeks. Je zou prima een hele ander oplossing kunnen vinden die net zo goed is. De gegeven algoritmen zijn dan ook niets meer dan suggesties. Probeer altijd zelf na te denken wat een handige oplossing zou kunnen zijn voor een gegeven probleem.
